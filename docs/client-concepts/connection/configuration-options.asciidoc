:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/5.2

:github: https://github.com/elastic/elasticsearch-net

:nuget: https://www.nuget.org/packages

////
IMPORTANT NOTE
==============
This file has been generated from https://github.com/elastic/elasticsearch-net/tree/5.x/src/Tests/ClientConcepts/Connection/ConfigurationOptions.doc.cs. 
If you wish to submit a PR for any spelling mistakes, typos or grammatical errors for this file,
please modify the original csharp file found at the link and submit the PR with that change. Thanks!
////

[[configuration-options]]
=== Configuration Options

Connecting to Elasticsearch with Elasticsearch.Net or NEST is easy, as demonstrated by the Getting started
documentation on the <<elasticsearch-net-getting-started, low level>> and <<nest-getting-started, high level>> clients demonstrates. 

There are a number of configuration options available on `ConnectionSettings` (and `ConnectionConfiguration` for
Elasticsearch.Net) that can be used to control how the clients interact with Elasticsearch.

==== Options on ConnectionConfiguration

The following is a list of available connection configuration options on `ConnectionConfiguration`; since`ConnectionSettings` derives from `ConnectionConfiguration`, these options are available for both 
Elasticsearch.Net and NEST:

`BasicAuthentication(string userName, string password)`::

Basic Authentication credentials to send with all requests to Elasticsearch

`ConnectionLimit(int connectionLimit)`::

Limits the number of concurrent connections that can be opened to an endpoint. Defaults to `80` .
+
For Desktop CLR, this setting applies to the DefaultConnectionLimit property on the  ServicePointManager object when creating ServicePoint objects, affecting the default `IConnection` implementation.
+
For Core CLR, this setting applies to the MaxConnectionsPerServer property on the HttpClientHandler instances used by the HttpClient inside the default `IConnection` implementation

`DeadTimeout(System.TimeSpan timeout)`::

Sets the default dead timeout factor when a node has been marked dead. Some connection pools may use a flat timeout whilst others take this factor and increase it exponentially

`DisableAutomaticProxyDetection(System.Boolean disable = true)`::

Disables the automatic detection of a proxy

`DisableDirectStreaming(System.Boolean b = true)`::

Ensures the response bytes are always available on the `ElasticsearchResponse<T>`
+
IMPORTANT: Depending on the registered serializer,             this may cause the response to be buffered in memory first, potentially affecting performance.

`DisablePing(System.Boolean disable = true)`::

When a node is used for the very first time or when it's used for the first time after it has been marked dead a ping with a very low timeout is send to the node to make sure that when it's still dead it reports it as fast as possible. You can disable these pings globally here if you rather have it fail on the possible slower original request

`EnableHttpCompression(System.Boolean enabled = true)`::

Enables gzip compressed requests and responses.
+
IMPORTANT: You need to configure http compression on Elasticsearch to be able to use this
+
http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-http.html

`EnableHttpPipelining(System.Boolean enabled = true)`::

Allows for requests to be pipelined. http://en.wikipedia.org/wiki/HTTP_pipelining
+
NOTE: HTTP pipelining must also be enabled in Elasticsearch for this to work properly.

`EnableTcpKeepAlive(System.TimeSpan keepAliveTime, System.TimeSpan keepAliveInterval)`::

Sets the keep-alive option on a TCP connection.
+
For Desktop CLR, sets ServicePointManager.SetTcpKeepAlive

`GlobalHeaders(System.Collections.Specialized.NameValueCollection headers)`::

A collection of headers that will be sent with every request. Useful in situations where you always need to pass a header e.g. a custom auth header

`GlobalQueryStringParameters(System.Collections.Specialized.NameValueCollection queryStringParameters)`::

A collection of query string parameters that will be sent with every request. Useful in situations where you always need to pass a parameter e.g. an API key.

`MaxDeadTimeout(System.TimeSpan timeout)`::

Sets the maximum time a node can be marked dead. Different implementations of `IConnectionPool` may choose a different default.

`MaximumRetries(int maxRetries)`::

The maximum number of retries for a given request,

`MaxRetryTimeout(System.TimeSpan maxRetryTimeout)`::

Limits the total runtime, including retries, separately from `RequestTimeout`
+
When not specified, defaults to `RequestTimeout` , which itself defaults to `60` seconds

`NodePredicate(Func<Elasticsearch.Net.Node,System.Boolean> predicate)`::

Register a predicate to select which nodes that you want to execute API calls on. Note that sniffing requests omit this predicate and always execute on all nodes. When using an `IConnectionPool` implementation that supports reseeding of nodes, this will default to omitting master only node from regular API calls.             When using static or single node connection pooling it is assumed the list of node you instantiate the client with should be taken verbatim.

`OnRequestCompleted(Action<Elasticsearch.Net.IApiCallDetails> handler)`::

Registers an `Action<T>` that is called when a response is received from Elasticsearch.             This can be useful for implementing custom logging.             Multiple callbacks can be registered by calling this multiple times

`OnRequestDataCreated(Action<Elasticsearch.Net.RequestData> handler)`::

Registers an `Action<T>` that is called when `RequestData` is created.             Multiple callbacks can be registered by calling this multiple times

`PingTimeout(System.TimeSpan timeout)`::

Sets the default ping timeout in milliseconds for ping requests, which are used to determine whether a node is alive. Pings should fail as fast as possible.

`PrettyJson(System.Boolean b = true)`::

Forces all requests to have ?pretty=true querystring parameter appended,  causing Elasticsearch to return formatted JSON. Also forces the client to send out formatted JSON. Defaults to `false`

`Proxy(System.Uri proxyAdress, string username, string password)`::

If your connection has to go through proxy, use this method to specify the proxy url

`RequestTimeout(System.TimeSpan timeout)`::

Sets the default timeout in milliseconds for each request to Elasticsearch. Defaults to `60` seconds.
+
NOTE: You can set this to a high value here, and specify a timeout on Elasticsearch's side.

`SniffLifeSpan(TimeSpan? sniffLifeSpan)`::

Set the duration after which a cluster state is considered stale and a sniff should be performed again. An `IConnectionPool` has to signal it supports reseeding, otherwise sniffing will never happen.             Defaults to 1 hour.             Set to null to disable completely. Sniffing will only ever happen on ConnectionPools that return true for SupportsReseeding

`SniffOnConnectionFault(System.Boolean sniffsOnConnectionFault = true)`::

Enables resniffing of the cluster when a call fails, if the connection pool supports reseeding. Defaults to `true`

`SniffOnStartup(System.Boolean sniffsOnStartup = true)`::

Enables sniffing on first usage of a connection pool if that pool supports reseeding. Defaults to `true`

`ThrowExceptions(System.Boolean alwaysThrow = true)`::

Instead of following a c/go like error checking on response.IsValid always throw an exception on the client when a call resulted in an exception on either the client or the Elasticsearch server.
+
Reasons for such exceptions could be search parser errors, index missing exceptions, etc...

:xml-docs: Elasticsearch.Net:ConnectionConfiguration`1

==== Options on ConnectionSettings

The following is a list of available connection configuration options on `ConnectionSettings`:

`DefaultFieldNameInferrer(Func<string,string> fieldNameInferrer)`::

Specify how field names are inferred from POCO property names.
+
By default, NEST camel cases property names  e.g. EmailAddress POCO property => "emailAddress" Elasticsearch document field name

`DefaultIndex(string defaultIndex)`::

The default index to use when no index is specified.

`DefaultTypeNameInferrer(Func<System.Type,string> typeNameInferrer)`::

Specify how type names are inferred from POCO types.  By default, type names are inferred by calling `ToLowerInvariant` on the type's name.

`MapDefaultTypeIndices(Action<FluentDictionary<System.Type,string>> mappingSelector)`::

Specify the default index names for a given POCO type.  Takes precedence over the global `DefaultIndex`

`MapDefaultTypeNames(Action<FluentDictionary<System.Type,string>> mappingSelector)`::

Specify the default type names for a given POCO type.  Takes precedence over the global `DefaultTypeNameInferrer`

`MapIdPropertyFor<TDocument>(Expression<Func<TDocument,object>> objectPath)`::

Specify which property on a given POCO should be used to infer the id of the document when  indexed in Elasticsearch. The type of the document.

`MapPropertiesFor<TDocument>(Action<PropertyMappingDescriptor<TDocument>> propertiesSelector)`::

Specify how the properties are mapped for a given POCO type. The type of the document.

`PluralizeTypeNames()`::

Pluralize type names when inferring from POCO type names.
+
This calls `DefaultTypeNameInferrer` with an implementation that will pluralize type names.              This used to be the default prior to Nest 0.90

:xml-docs: Nest:ConnectionSettingsBase`1

Here's an example to demonstrate setting configuration options.

[source,csharp]
----
var connectionConfiguration = new ConnectionConfiguration()
    .DisableAutomaticProxyDetection() 
    .EnableHttpCompression() 
    .DisableDirectStreaming()
    .PrettyJson()
    .RequestTimeout(TimeSpan.FromMinutes(2));
var client = new ElasticLowLevelClient(connectionConfiguration);
----

[NOTE]
====
Basic authentication credentials can alternatively be specified on the node URI directly:

[source,csharp]
----
var uri = new Uri("http://username:password@localhost:9200");

var settings = new ConnectionConfiguration(uri);
----

...but this may become tedious when using connection pooling with multiple nodes.

====

[float]
=== OnRequestCompleted

You can pass a callback of type `Action<IApiCallDetails>` that can eavesdrop every time a response (good or bad) is created.
If you have complex logging needs this is a good place to add that in.

[source,csharp]
----
var counter = 0;

var client = TestClient.GetInMemoryClient(s => s.OnRequestCompleted(r => counter++));

client.RootNodeInfo();

counter.Should().Be(1);

client.RootNodeInfoAsync();

counter.Should().Be(2);
----

`OnRequestCompleted` is called even when an exception is thrown

[source,csharp]
----
var counter = 0;

var client = TestClient.GetFixedReturnClient(new { }, 500, s => s
    .ThrowExceptions()
    .OnRequestCompleted(r => counter++)
);

Assert.Throws<ElasticsearchClientException>(() => client.RootNodeInfo());

counter.Should().Be(1);

Assert.ThrowsAsync<ElasticsearchClientException>(() => client.RootNodeInfoAsync());

counter.Should().Be(2);
----

[[complex-logging]]
[float]
=== Complex logging with OnRequestCompleted

Here's an example of using `OnRequestCompleted()` for complex logging. Remember, if you would also like
to capture the request and/or response bytes, you also need to set `.DisableDirectStreaming()` to `true`

[source,csharp]
----
var list = new List<string>();

var connectionPool = new SingleNodeConnectionPool(new Uri("http://localhost:9200"));

var settings = new ConnectionSettings(connectionPool, new InMemoryConnection()) <1>
    .DefaultIndex("default-index")
    .DisableDirectStreaming()
    .OnRequestCompleted(response =>
    {
        // log out the request and the request body, if one exists for the type of request
        if (response.RequestBodyInBytes != null)
        {
            list.Add(
                $"{response.HttpMethod} {response.Uri} \n" +
                $"{Encoding.UTF8.GetString(response.RequestBodyInBytes)}");
        }
        else
        {
            list.Add($"{response.HttpMethod} {response.Uri}");
        }

        // log out the response and the response body, if one exists for the type of response
        if (response.ResponseBodyInBytes != null)
        {
            list.Add($"Status: {response.HttpStatusCode}\n" +
                     $"{Encoding.UTF8.GetString(response.ResponseBodyInBytes)}\n" +
                     $"{new string('-', 30)}\n");
        }
        else
        {
            list.Add($"Status: {response.HttpStatusCode}\n" +
                     $"{new string('-', 30)}\n");
        }
    });

var client = new ElasticClient(settings);

var syncResponse = client.Search<object>(s => s
    .AllTypes()
    .AllIndices()
    .Scroll("2m")
    .Sort(ss => ss
        .Ascending(SortSpecialField.DocumentIndexOrder)
    )
);

list.Count.Should().Be(2);

var asyncResponse = await client.SearchAsync<object>(s => s
    .AllTypes()
    .AllIndices()
    .Scroll("2m")
    .Sort(ss => ss
        .Ascending(SortSpecialField.DocumentIndexOrder)
    )
);

list.Count.Should().Be(4);

list.ShouldAllBeEquivalentTo(new[]
{
    "POST http://localhost:9200/_search?scroll=2m \n{\"sort\":[{\"_doc\":{\"order\":\"asc\"}}]}",
    "Status: 200\n------------------------------\n",
    "POST http://localhost:9200/_search?scroll=2m \n{\"sort\":[{\"_doc\":{\"order\":\"asc\"}}]}",
    "Status: 200\n------------------------------\n"
});
----
<1> Here we use `InMemoryConnection`; in reality you would use another type of `IConnection` that actually makes a request.

[[configuring-ssl]]
[float]
=== Configuring SSL

SSL can be configured via the `ServerCertificateValidationCallback` property on either `ServerPointManager` or `HttpClientHandler`
depending on which version of the .NET framework is in use.

On the full .NET Framework, this must be done outside of the client using .NET's built-in http://msdn.microsoft.com/en-us/library/system.net.servicepointmanager%28v=vs.110%29.aspx[ServicePointManager] class:

[source,csharp]
----
ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, errors) => true;
----

The bare minimum to make .NET accept self-signed SSL certs that are not in the Windows CA store would be to have the callback simply return `true`.

However, this will accept **all** requests from the AppDomain to untrusted SSL sites,
therefore **we recommend doing some minimal introspection on the passed in certificate.**

